1. 编译运行
	1.1 mkdri -p catkin_ws/src
	1.2 mv A-LOAM catkin_ws/src/
	1.3 cd catkin_ws
	1.4 catkin_make
	1.5 source devel/setup.bash
	1.6 roslaunch aloam_velodyne aloam_velodyne_VLP_16.launch
	1.7 rosbag play ***.bag


2. 前端配准：雷达坐标系：左-前-上
	2.1 将ros格式的点云转换为pcl
	2.2 去除nan的点云removeNaNFromPointCloud：调用PCL的接口实现
	2.3 去除近点removeClosedPointCloud：直接计算每一个点云的模长，如果模长小于阈值，就将其删除；算法实现的时候是直接在点云上进行修改，不会copy一份出来，这种处理方式可以学习借鉴，尤其是在数据量非常大的时候

	2.4 计算每一个点云相对于起始的时间：
		2.4.1 计算每一次扫描的起始角度startOri和结束角度endOri，计算的时候保证startOri与endOri之间间隔在2pi附近
		2.4.2 对每一个点，首先计算其角度ori，然后根据其halfPassed来修正ori
		2.4.3 根据(ori-startOri)/(endOri-startOri)计算当前点相对于起始时刻的时间的比例，并存储于intensity之中

	2.5 计算每一个点云对应的线束scanID：
		2.5.1 计算每一个点的俯仰角，根据Lidar硬件的属性来判断每一个点在哪一个线束上
		2.5.2 对于16线激光：相邻线束相隔2度，排列分别为-15、-13、...-1、1、...、13、15

	2.6 计算roughness：注意点云的存储是按照scan存储的
		2.6.1 从第六个点开始计算roughness，一直计算到倒数第六个点
		2.6.2 对每一维，选择其左边的五个点和右边的五个点（左边还是右边是根据索引直接获取的，因此每一个scan（不包括第一个scan的起始和最后一个scan的结尾）的起始5个点和结束的五个点虽然计算了，但是后面并没有用到，实际上计算也无法使用，这个很容易理解），将这10个点的这一维的数值相加并减去10倍的当前点的这个维度的数值
		2.6.3 将2.6.2中计算的每一个维度取平方并相加，并保存到cloudCurvature中，cloudSortInd中存储当前点的索引，cloudNeighborPicked和cloudLabel存储的全是0

	2.7 提取线点和面点：
		2.7.1 计算每一个线束的起始计算索引scanStartInd和结束计算索引scanEndInd，每一个线束的前四个点和最后四个点都不计算
		2.7.2 对每一个scan，如果这个线束的点云的数量不超过6个，那么直接跳过，不计算；否则继续执行
		2.7.3 根据scanStartInd和scanEndInd将当前线束6等分，对每一等分，计算起始索引sp和结束索引ep，然后对当前等分根据曲率正向排序
		2.7.4 对每一等分：
			1. cornerPointsSharp：选择2个曲率大的线点，并标记cloudLabel为2；需要保证选择的时候周围点没有被选择，并且曲率大于0.1，同时将其也存储到一般的线点cornerPointsLessSharp中，标记这个点已经被选择，也就是cloudNeighborPicked标记为1
			2. cornerPointsLessSharp：选择20个曲率一般大的线点，并标记cloudLabel为1；需要保证选择的时候周围点没有被选择；实际上，按照曲率，前两个点存储到cornerPointsSharp中，前20个点存储到cornerPointsLessSharp中，标记这个点已经被选择，也就是cloudNeighborPicked标记为1
			3. surfPointsFlat：选择4个曲率小的面点，并标记cloudLabel为-1；需要保证选择的时候周围点没有被选择，并且曲率小于0.1，标记这个点已经被选择，也就是cloudNeighborPicked标记为1
			4. surfPointsLessFlatScan：对当前等分的所有的点云，如果其cloudLabel小于等于0，那就是一般的面点；也就是除了cornerPointsSharp和cornerPointsLessSharp的所有点都是一般的面点，在这里不再判断cloudNeighborPicked了；由于这种点比较多，因此对其进行体素滤波，并将结果保存到surfPointsLessFlat中
			5. 对每一个选择的点，判断其左右的点云是否连续，如果是连续的就标记左右的点云的cloudNeighborPicked为1；连续的判断方法是连续两个点的距离，判断距离是否大于0.05，如果大于就直接认为是非连续的

	2.8 发布消息：
		2.8.1 将所有的点云laserCloud、线点cornerPointsSharp、一般的线点cornerPointsLessSharp、面点surfPointsFlat、一般的面点surfPointsLessFlat都发布出去，由雷达里程计或者雷达建图接收


3. 雷达里程计
	3.1 如果线点cornerSharpBuf、一般的线点cornerLessSharpBuf、面点surfFlatBuf、一般的面点surfLessFlatBuf和所有的点云fullPointsBuf有一个为空，那么直接结束
	3.2 分别取出cornerSharpBuf、cornerLessSharpBuf、surfFlatBuf、surfLessFlatBuf和fullPointsBuf的第一个时间，如果这5个时间不相等，那么直接运行ROS_BREAK，否则继续往后面执行
	3.3 取出线点到cornerSharpBuf，取出一般的线点到cornerLessSharpBuf，取出面点到surfFlatBuf，取出一般的面点到surfLessFlatBuf，取出所有的点云到fullPointsBuf
	3.4 对于第一帧扫描，将当前一般线点（其中必然包含了线点）和一般面点（其中必然包含了面点）赋值给laserCloudCornerLast和laserCloudSurfLast，为后面的操作做准备；对于非第一帧，就是将当前帧的数据赋值给上一帧；使用laserCloudCornerLast构建KD树kdtreeCornerLast，使用laserCloudSurfLast构建KD树kdtreeSurfLast；按照指定的频率发布当前帧一般的角点和一般的面点
	3.5 TransformToStart：
		3.5.1 计算当前到起始的时间的比例
		3.5.2 使用已经有的q_last_curr通过四元数球面插值计算当前时刻到起始的旋转变换
		3.5.3 对平移执行线性插值，计算当前时刻到起始的平移变换
		3.5.4 通过计算的变换，将当前的点云变换到起始时刻
	3.6 TransformToEnd：
		3.6.1 调用TransformToStart将点云转换到起始时刻
		3.6.2 通过q_last_curr将点云变换到结束时刻
	3.7 通过两次迭代，每一次迭代：
		3.7.1 对每一个角点：
			1. 将其变化到当前帧的起始时刻，然后在kdtreeCornerLast（使用一般的线点构建）中搜索距离最近的一个点，要求这个最近距离小于阈值
			2. 获取最近点的索引，在其左右两边的某个范围内（在上下3个线束内且与当前点云不同线束）搜索在距离阈值范围内的最近点，并获取其索引
			3. 通过获取当前这个面点和最近的两个点（不同线束的近点），构建一个点到线的距离的BA问题
		3.7.2 对每一个面点：
			1. 将其变化到当前帧的起始时刻，然后在kdtreeSurfLast（使用一般的面点构建）中搜索最近的一个点，要求这个最近距离小于阈值
			2. 获取最近点的索引，在其左右两边的某个范围内（在上下3个线束内且与当前点云不同线束）搜索在距离阈值范围内的最近点，并获取其索引；在当前点的相同线束上搜索一个最近点，并获取其索引；这里的距离也要满足最近的距离阈值
			3. 通过获取当前这个面点和最近的三个点（一个最近点，一个与最近点同线束的近点，另外两个不同线束的近点），构建一个点到平面距离的BA问题
		3.7.3 通过ceres求解当前帧到上一帧的变换t_last_curr和q_last_curr，据此更新当前帧到世界的变换t_w_curr和q_w_curr
	3.8 记录激光里程计的旋转和平移（当前帧到世界），并将位姿发布出去；



4. 后端建图
	4.1 确保由里程计发布的一般的线点、一般的面点、当前帧的所有的点云和里程计计算的位姿都非空
	4.2 以一般的线点的时间戳为准，将其前面的里程计的一般的面点、所有的点云和里程计的位姿都删除，知道时间戳对齐；然后将一般的线点、一般的面点和所有的点云都转成PCL格式；并获取里程计发布的当前帧到世界的位姿变换；删除里程计队列中所有的缓存，避免产生延时（相当于某些帧并不处理）
	4.3 transformAssociateToMap：由于里程计发布的结果会有漂移，因此其发布的当前帧到世界的变换并不一定准确，因此还会计算一个里程计的世界系到世界系的变换（初始为单位阵），并据此计算当前帧到世界的变换
	4.4 计算当前帧在地图中的位置
		4.4.1 刚开始的时候，当前帧当然在地图的中间位置，但是随着系统的运行，当前帧一定会运行到地图的边缘，这个时候就会修改地图，使得当前帧依然在地图的大约中间位置
		4.4.2 地图有多个50*50*50的立方体组成，x方向有21个立方体，y方向有21个立方体，z方向有11个立方体
		4.4.3 根据初始的当前帧的位姿计算当前帧在地图中的位置
		4.4.4 如果当前帧在地图的边缘，就开始调整地图，需要注意的是，点云实际上是不动的，改变的仅仅只是地图中的立方体中的点云，比如后一个立方体的点云更新为前一个立方体等：
			1. 如果x方向到达左边缘，那么就往左边移动地图的立方体，从相对的角度将，就是将点云往右边移动，注意这里说的是相对
			2. 如果x方向到达右边缘，那么就往右边移动地图的立方体，从相对的角度将，就是将点云往左边移动，注意这里说的是相对
			3. 需要注意的是，laserCloudCenWidth会同步发生变化，以适应centerCubeI的计算，例如如果x方向到达左边缘，那么移动过程中centerCubeI会递增，那为了在式子centerCubeI = int((t_w_curr.x() + 25.0) / 50.0) + laserCloudCenWidth中体现centerCubeI递增，那么就要laserCloudCenWidth递增，这样后面再来一帧的时候，就可以按照更新后的地图来计算了，这个laserCloudCenWidth正好适应这个时候的计算
			4. 对于y方向和z方向的计算都是一样的
	4.5 选择局部地图，也就是当前帧周围的点云：x方向±2，y方向±2，z方向±1，选择当前帧周围的这些立方体，并保存这些立方体在地图中的索引，用于后面的索引
	4.6 根据上一步获取的局部地图索引获取这些索引对应的一般的线点（注意地图是根据一般的线点/面点构建的，并且有两个地图，一个是关于线点的，一个是关于面点的，他们的规格完全一样，仅仅只是立方体中保存的点云的type不一样）
	4.7 对于当前帧的一般的线点和一般的面点都使用体素滤波进行下采样，用于降低计算量；如果剩余的当前帧的一般的线点的数量小于等于10个或者一般的面点的数量小于等于50个，那么都不会进行优化，并直接调到。。。，否则，开始查找线点和面点的关联，进行优化
	4.8 对于当前帧位姿的优化：当前帧到世界的位姿，注意不是里程计的世界，而是地图的世界
		4.8.1 通过4.5中获取的局部地图构建关于线点的KD树kdtreeCornerFromMap和关于面点的KD树kdtreeSurfFromMap
		4.8.2 构建BA问题，并使用Huber的核函数
		4.8.3 对于下采样后的当前帧的每一个一般的线点，在kdtreeCornerFromMap中寻找5个最近点，要求这5个最近点的距离都在阈值范围内，然后计算这5个最近点构成的点集的主方向，也就是要求他们近似在一条直线上，这里的判断方法是最大的特征值显著地大于其次大的特征值（不再跟里程计中需要判断不能在一个线束上了）；如果这个点集近似分布于一条直线上，那么选择主方向上的两个点，并据此构建当前帧的线点到地图中的两个线点的距离
		4.8.4 对于下采样后的当前帧的每一个一般的面点，在kdtreeSurfFromMap中寻找5个最近点，要求这5个最近点的距离都在阈值范围内，然后根据这5个点拟合一个平面，并计算每个点到这个平面的距离，并据此判断这5个点是否分布与一个平面附近（不再跟里程计中需要判断线束了）；如果确实分布于一个平面附近，就根据法向量和当前帧的面点构建点到平面的距离
		4.8.5 优化两次，上一次优化的结果会在当前帧的线点/面点投影到地图的时候的计算更加准确，也就是构建的匹配更加准确；层层递进
		4.8.6 根据优化结果，更新里程计的世界系到地图的世界系的变换
	4.9 更新地图：将当前帧的一般的线点/面点添加到地图中
		4.9.1 对下采样后的线点，先将其投影到地图中，然后判断其在地图的哪一个立方体中，只要这个立方体没有越界，就将其添加到这个立方体中
		4.9.2 对下采样后的面点也是一样的处理方法
		4.9.3 对下采样后的线点/面点进行下采样，然后更新立方体中的点云
	4.10 发布
		4.10.1 每隔5帧发布当前帧周围的局部地图
		4.10.2 每隔20帧发布地图
		4.10.3 发布当前帧的所有的点云，注意这里发布的点云已经全部投影到地图世界系了
		4.10.4 发布经过配准地图的当前帧的位姿
		4.10.5 发布轨迹
		4.10.6 发布tf
